// This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
// To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ or send a letter to
// Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

#include "odeproblem.h"
#include "RcppInclude.h"

#define CRUMP(a) Rcpp::stop(a)
#define REP(a)   Rcpp::Rcout << #a << std::endl;
#define nREP(a)  Rcpp::Rcout << a << std::endl;
#define say(a)   Rcpp::Rcout << a << std::endl;


/** Perform a simulation run.
 * 
 * @param parin list of data and options for the simulation
 * @param inpar numeric parameter values
 * @param parnames parameter names
 * @param init numeric initial values
 * @param cmtnames compartment names
 * @param capture indices in capture vector to actually get
 * @param funs list of pointer addresses to model functions generated by 
 * getNativeSymbolInfo()
 * @param data the main data set
 * @param idata the idata data aset
 * @param OMEGA between-ID normal random effects
 * @param SIGMA within-ID normal random effects
 * @return list containing matrix of simulated data and a character vector of
 * tran names that may have been carried into the output
 *
 */

namespace {
  unsigned int timecol = 1;
  unsigned int cmtcol  = 2;
  unsigned int evidcol = 3;
  unsigned int amtcol  = 4;
}
// [[Rcpp::export]]
Rcpp::NumericMatrix QUICKSIM(const Rcpp::List& parin,
                             const Rcpp::NumericVector& param,
                             const Rcpp::NumericVector& init,
                             const Rcpp::NumericMatrix& data,
                             const Rcpp::NumericMatrix& idata,
                             const Rcpp::IntegerVector& capturei,
                             const Rcpp::List& funs) {
  
  const int capn = capturei.at(0);
  
  odeproblem prob(param, init, funs, capn);
  
  prob.copy_parin(parin);
  
  double NN = data.nrow() * idata.nrow();
  
  const unsigned int neq = prob.neq();
  
  Rcpp::NumericMatrix ans(NN,neq+1+capn);
  
  double tto =0;
  double tfrom = data(0,timecol);
  int capstart = 1 + neq;
  int crow = 0;
  int k; 
  
  // Simulate each individual
  for(int i = 0; i < idata.nrow(); ++i) {
    
    for(k = 0; k < neq; ++k) {
      prob.y_init(k,init[k]); 
    }
    prob.init_call(tto);
    prob.lsoda_init();
    
    tfrom = data(0,timecol);

    // Simulate the same data set
    for(int j = 0; j < data.nrow(); ++j) {
      
      tto = data(j,timecol);
    
      prob.advance(tfrom,tto);
      
      if(data(j,evidcol)==1) {
        prob.y(data(j,cmtcol)-1,data(j,amtcol) + prob.y(data(j,cmtcol)-1));
        prob.lsoda_init();
      }
      
      prob.table_call();
      ans(crow,0) = data(j,timecol);
      ans(crow,1) = idata(i,1);
      
      for(k = 0; k < neq;  ++k) ans(crow,1+k) = prob.y(k);
      for(k = 0; k < capn; ++k) {
        ans(crow,capstart+k) = prob.capture(capturei[1+k]); 
      }
      tfrom  = tto;
      ++crow;
    }
  }
  // Clean up
  return ans;
}


