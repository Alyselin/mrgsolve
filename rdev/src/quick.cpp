// This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
// To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ or send a letter to
// Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

#include "odeproblem.h"
#include "RcppInclude.h"
#include "dataobject.h"
#include "mrgsolve.h"

/** Perform a simple simulation run.
 * 
 * @param parin list of data and options for the simulation
 * @param inpar numeric parameter values
 * @param parnames parameter names
 * @param init numeric initial values
 * @param cmtnames compartment names
 * @param capture indices in capture vector to actually get
 * @param funs list of pointer addresses to model functions generated by 
 * getNativeSymbolInfo()
 * @param data the main data set
 * @param idata the idata data aset
 * @param OMEGA between-ID normal random effects
 * @param SIGMA within-ID normal random effects
 * @return list containing matrix of simulated data and a character vector of
 * tran names that may have been carried into the output
 *
 */

typedef  Rcpp::NumericMatrix::Column mcol;

namespace {
unsigned int timecol = 1;
  unsigned int cmtcol  = 2;
  unsigned int evidcol = 3;
  unsigned int amtcol  = 4;
  unsigned int ratecol = 5;
}
// [[Rcpp::export]]
Rcpp::NumericMatrix QUICKSIM(const Rcpp::List& parin,
                             const Rcpp::NumericVector& param,
                             const Rcpp::NumericVector& init,
                             Rcpp::CharacterVector& parnames,
                             Rcpp::CharacterVector& cmtnames,
                             Rcpp::NumericMatrix& data,
                             const Rcpp::NumericMatrix& idata,
                             const Rcpp::IntegerVector& capturei,
                             const Rcpp::List& funs) {
  
  dataobject idat(idata,parnames,cmtnames);
  
  const int capn = capturei.at(0);
  
  odeproblem prob(param, init, funs, capn);
  
  prob.copy_parin(parin);
  
  const unsigned int NN = data.nrow() * idata.nrow();
  
  const unsigned int neq = prob.neq();
  
  Rcpp::NumericMatrix ans(NN,2+neq+capn);
  
  mcol time = data(Rcpp::_,timecol);
  mcol evid = data(Rcpp::_,evidcol);
  mcol amt = data(Rcpp::_,amtcol);
  mcol cmt = data(Rcpp::_,cmtcol);
  mcol rate = data(Rcpp::_,ratecol);
  cmt = cmt-1;
  
  double tto =0;
  double tfrom = time[0];
  const int capstart = 2 + neq;
  int crow = 0;
  int k; 
  double ID = 0;
  
  size_t irow = idata.nrow();
  size_t drow = data.nrow();
  
  // Simulate each individual
  for(size_t i = 0; i < irow; ++i) {
    
    idat.copy_parameters(i,&prob);
    
    prob.y_init(init);
    prob.init_call(tto);
    prob.lsoda_init();
    
    ID = idata(i,0);
    prob.reset_newid(ID);
    
    if(i==0) prob.newind(0);
    
    tfrom = time[0];
    
    // Simulate the same data set
    for(size_t j = 0; j < drow; ++j) {
      
      if(j==0) {
        prob.newind(1);
      } else {
        prob.newind(2); 
      }
      
      tto = time[j];
      
      prob.advance(tfrom,tto);
      
      if(evid[j]==1) {
        if(rate[j] > 0) {
          prob.rate_bump(cmt[j],rate[j]);
        } else {
          prob.y_add(cmt[j],amt[j]);
        }
        prob.lsoda_init();
      }
      
      prob.table_call();
      
      ans(crow,0) = ID;
      ans(crow,1) = time[j];
      
      for(k = 0; k < neq;  ++k) ans(crow,2+k) = prob.y(k);
      
      for(k = 0; k < capn; ++k) {
        ans(crow,capstart+k) = prob.capture(capturei[1+k]); 
      }
      
      tfrom  = tto;
      ++crow;
    }
  }
  return ans;
}

// [[Rcpp::export]]
Rcpp::NumericMatrix PREDSIM(const Rcpp::List& parin,
                            const Rcpp::NumericVector& param,
                            const Rcpp::NumericVector& init,
                            Rcpp::CharacterVector& parnames,
                            Rcpp::CharacterVector& cmtnames,
                            const Rcpp::NumericMatrix& idata,
                            const Rcpp::IntegerVector& capturei,
                            const Rcpp::List& funs) {
  
  dataobject idat(idata,parnames);

  const int capn = capturei.at(0);
  odeproblem prob(param, init, funs, capn);
  Rcpp::NumericMatrix ans(idata.nrow(),capn);
  
  int k; 
  size_t irow = idata.nrow();
  
  // Simulate each individual
  for(size_t i = 0; i < irow; ++i) {
    idat.copy_parameters(i,&prob);
    prob.init_call(0.0);
    prob.table_call();
    for(k = 0; k < capn; ++k) {
      ans(i,k) = prob.capture(capturei[1+k]); 
    }
  }
  return ans;
}



