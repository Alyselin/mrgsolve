## This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
## To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ or send a letter to
## Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

##' @include utils.R complog.R nmxml.R matrix.R annot.R

globalre2 <- "^\\s*(predpk|double|bool|int)\\s+\\w+"
block_re <-  "^\\s*(\\$([A-Z]\\w*)|\\[\\s*([A-Z]\\w*)\\s*])(.*)"

## Generate an advan/trans directive
advtr <- function(advan,trans) {
  if(advan==13 | trans==1) return(NULL)
  if((advan %in% c(1,2)) & !(trans %in% c(2,11))) {
    stop("ADVAN 1 and 2 can only use trans 1, 2, or 11", call.=FALSE)
  }
  if((advan %in% c(3,4)) & !(trans %in% c(4,11))) {
    stop("ADVAN 3 and 4 can only use trans 1, 4, or 11", call.=FALSE)
  }
  return(paste0("__ADVAN", advan, "_TRANS", trans, "__"))
}


write_capture <- function(x) {
  if(length(x)==0) return(NULL)
  i <- seq_along(x)
  paste0("_capture_[",i-1,"] = ", x[i], ";") 
}

## These are arguments to mrgsim that
## can be stated in $SET and then passed to mrgsim
set_args <- c("Req", "obsonly","mtime", "recsort",
              "carry.out","Trequest","trequest")

check_spec_contents <- function(x,crump=TRUE,warn=TRUE,...) {
  invalid <- setdiff(x,block_list)
  valid <- intersect(x,block_list)
  
  if(sum(is.element("TABLE",x)) > 1) stop("Only one $TABLE block allowed.",call.=FALSE)
  if(sum(is.element("MAIN",x))  > 1) stop("Only one $MAIN block allowed.",call.=FALSE)
  if(sum(is.element("ODE",x))   > 1) stop("Only one $ODE block allowed.",call.=FALSE)
  if(sum(is.element("SET",x))   > 1) stop("Only one $SET block allowed.",call.=FALSE)
  if(sum(is.element("MAIN",x))  > 1) stop("Only one $MAIN block allowed.",call.=FALSE)
  
  if(warn) {
    if(sum(is.element(c("INIT", "CMT"),x)) == 0)  warning("Could not find a $INIT or $CMT block", call.=FALSE)
    if(length(invalid)>0) {
      warning(paste0("Invalid blocks found: ", paste(invalid, collapse=" ")), call.=FALSE)
    }
  }
  if(length(valid)==0) stop("No valid blocks found.", call.=FALSE)
  
}

audit_spec <- function(x,spec,warn=TRUE) {
  
  cmt <- names(init(x))
  
  if(warn) {
    if(exists("ODE", spec)) {
      eq <- paste0("dxdt_",cmt)
      z <- rep(FALSE, length(cmt))
      for(i in seq_along(cmt)) z[i] <- !any(grepl(eq[i],spec$ODE, perl=TRUE)  )
      if(any(z)) {
        ans <- paste(cmt[z], collapse=',')
        warning(paste0("Audit: missing differential equation(s) for ", ans), call.=FALSE)
      }
    }
  }
  
  return(invisible(NULL))
}


define_digits <- function(x) {
  x <- as.character(x)
  fix <- grep("[.+-]", x, invert=TRUE)
  x[fix] <- paste0(x[fix], '.0')
  x
}

fixed_parameters <- function(x,fixed_type) {
  if(length(x)==0) return("// No fixed parameters.")
  if(is.null(fixed_type))  fixed_type <-  "define"
  if(!(fixed_type %in% c("define", "const"))) stop("fixed_type must be either const or define.", call.=FALSE)
  switch(fixed_type,
         `const` =  paste0("const double ", paste0(names(x) ,"= " ,unlist(x), ";")),
         `define` = paste0("#define ", names(x), "  (", define_digits(unlist(x)),")")
  )
}

## A random file name
so_stem <- function(x) paste0(x,"-so-")

rfile <- function(pattern="",tmpdir=normalizePath(getwd(),winslash="/")){
  basename(tempfile(pattern=so_stem(pattern),tmpdir='.'))
}

## Form a file name / path for the file that is actually compiled
comppart <- "-mread-source"
compbase <- function(model) paste0(model, comppart)
compfile <- function(model) paste0(model, comppart,".cpp")
compout  <- function(model) paste0(model, comppart, .Platform$dynlib.ext)
compdir <- function() {
  paste(c("mrgsolve",
          "so",
          as.character(GLOBALS[["version"]]),
          R.version$platform),
        collapse="-")
}

setup_soloc <- function(loc,model) {
  soloc <- file.path(loc,compdir(),model)
  if(!file.exists(soloc)) dir.create(soloc,recursive=TRUE)
  return(soloc)
}

# protected_options <- function(x) {
#   x <- as.cvec2(x)
#   d <- !grepl("=",x,fixed=TRUE) & nchar(x) > 0
#   x[d] <- sapply(x[d],function(y) paste0(y, "=TRUE"))
#   paste0(">> ",paste(x,collapse=','))
# }


##' Parse model specification text.
##' @param txt model specification text
##' @param split logical
##' @param drop_blank logical; \code{TRUE} if blank lines are to be dropped
##' @param comment_re regular expression for comments
##' @param ... arguments passed along
##' @export
modelparse <- function(txt, 
                       split=FALSE,
                       drop_blank = TRUE, 
                       comment_re="//+|##+",...) {
  
  ## Take in model text and parse it out
  
  if(split) txt <- strsplit(txt,"\n",perl=TRUE)[[1]]
  
  txt <- strsplit(txt, comment_re, perl=TRUE)
  
  txt <- sapply(txt, `[`,1L)
  
  if(drop_blank) {
    txt <- txt[!is.na(txt) & !grepl("^\\s*$",txt,perl=TRUE)]
  } else {
    txt[is.na(txt)] <- "\n"
  }
  
  start <- grep(block_re,txt,perl=TRUE)
  
  if(length(start)==0) stop("No model specification file blocks were found.", call.=FALSE)
  
  labs <- gsub(block_re,"\\2\\3", txt[start],perl=TRUE)
  
  txt[start] <- gsub(block_re, "\\4", txt[start],perl=TRUE)
  
  end <- c((start-1),length(txt))[-1]
  
  spec <- lapply(seq_along(start), function(i) {
    y <- txt[start[i]:end[i]]
    y[y!=""]
  })
  
  names(spec) <- labs
  
  return(spec)
  
}


## ----------------------------------------------------------------------------
## New function set for finding double / bool / int
## and moving to global
move_global_re_find <- "\\b(double|int|bool|capture)\\s+\\w+\\s*="
move_global_re_sub <- "\\b(double|bool|int|capture)\\s+(\\w+\\s*=)"
local_var_typedef <- c("typedef double localdouble;","typedef int localint;","typedef bool localbool;")
move_global <- function(x,env,what=c("MAIN", "ODE", "TABLE")) {
  what <- intersect(what,names(x))
  if(length(what)==0) return(x)
  l <- lapply(x[what], get_c_vars) %>% unlist
  x[["GLOBAL"]] <- c(x[["GLOBAL"]],
                     "typedef double capture;",l,local_var_typedef)
  for(w in what) {
    x[[w]] <- gsub(move_global_re_sub,"\\2",
                   x[[w]],perl=TRUE)
  }
  cap <- grepl("^capture ", l, perl=TRUE)
  
  if(any(cap)) {
    cap <- trimws(unlist(strsplit(l[cap], "capture |;",perl=TRUE)))
    env[["capture"]] <- cap[cap!=""]
    if(is.null(x[["CAPTURE"]])) x[["CAPTURE"]] <- ""
  }
  return(x)
}
get_c_vars <- function(y) {
  m <- gregexpr(move_global_re_find,y,perl=TRUE)
  regmatches(y,m) %>%
    unlist %>%
    gsub(pattern="\\s*=$",
         replacement=";",
         perl=TRUE)
}
## ----------------------------------------------------------------------------


# opts_only <- function(x,def=list(),all=FALSE) {
#   opts <- scrape_opts(x)
#   merge(def,opts, strict=!all,warn=FALSE,context="opts")
# }

##' Scrape options from a code block.
##' 
##' @param x data
##' @param def default values
##' @param all return all options, even those that are not in \code{def}
##' @param marker assignment operator; used to locate lines with options
##' @param narrow logical; if \code{TRUE}, only get options on lines starting with \code{>>}
##' @param envir environment from \code{$ENV}
##' 
##' @return list with elements \code{x} (the data without options) and named options 
##' as specified in the block.
##' 
##' 
scrape_opts <- function(x,envir=list(),def=list(),all=TRUE,marker="=>?",narrow=FALSE) {
  
  x <- unlist(strsplit(x, "\n",fixed=TRUE))
  
  ## Get lines starting with >>
  opts <- grepl("^\\s*>>",x,perl=TRUE)
  
  if(!narrow) {
    opts <- opts | grepl(marker,x,perl=TRUE) 
  }
  
  data <- gsub("^\\s*$", "", x[!opts], perl=TRUE)

  opts <- gsub(">>","", x[opts], fixed=TRUE)
  
  opts <- merge(def, tolist(opts,envir=envir),strict=!all,warn=FALSE,context="opts")
  
  opts$x <- NULL
  
  c(list(x=data), opts)
}

scrape_and_pass <- function(x,pass,env,...) {
  o <- scrape_opts(x,envir=env$ENV,...)
  o$pos <- o$env <- o$class <- NULL
  o <- c(o,attributes(x),list(env=env))
  ret <- do.call(pass,o)
  list(opts=o,data=ret)
}

##' Scrape options and pass to function.
##' 
##' @param x data
##' @param env parse environment
##' @param pass function to call
##' @param ... dots
##' 
##' @details Attributes of \code{x} are also scraped and merged with options.
##' 
scrape_and_call <- function(x,env,pass,...) {
  o <- scrape_opts(x,envir=env$ENV,...)
  o$pos <- o$env <- o$class <- NULL
  o <- c(o,attributes(x),list(env=env))
  do.call(pass,o)
}

dump_opts <- function(x,env,block,...) {
  hasopt <- grep(">>", x, fixed=TRUE)
  if(length(hasopt)==0) return(x)
  hasopt <- grep("^\\s*>>", x[hasopt], perl=TRUE)
  x[-hasopt]
}

## Functions for handling code blocks
parseNMXML <- function(x,env,...) {
  pos <- attr(x,"pos")
  x <- tolist(x,envir=env$ENV)
  xml <- do.call(nmxml,x)
  env[["param"]][[pos]] <- xml$theta
  env[["omega"]][[pos]] <- xml$omega
  env[["sigma"]][[pos]] <- xml$sigma
  return(NULL)
}

parseLIST <- function(x,where,env,...) {
  env[[where]][[attr(x,"pos")]] <- tolist(x)
  return(NULL)
}

## Used to parse OMEGA and SIGMA matrix blocks
specMATRIX <- function(x,
                       oclass,type, annotated = FALSE,
                       env, pos=1,
                       name="...", prefix="", labels=NULL,
                       object=NULL,...) {
  
  if(annotated) {
    l <- parse_annot(x,block=toupper(type),envir=env$ENV,name_value=FALSE)
    d <- modMATRIX(l[["v"]],context=oclass,...)
    labels <- l[["an"]][["name"]]
    env[["annot"]][[pos]] <- l[["an"]]
    
  } else {
    if(is.null(object)) {
      d <- modMATRIX(x,context=oclass,...) 
    } else {
      d <- get(object,env$ENV)
    }
  }
  
  
  if(nrow(d)==0) stop("mrgsolve: the matrix must have at least 1 row (", oclass, ").",call.=FALSE)
  
  if(is.null(labels)) {
    labels <- rep(".", nrow(d))
  } else {
    labels <- paste0(prefix,tovec(labels))
  }
  
  d <- setNames(list(d),name)
  
  x <- create_matlist(d,class=oclass,labels=list(labels))
  
  env[[type]][[pos]] <- x
  
  return(NULL)
}


##' @export
handle_spec_block.specOMEGA <- function(x,...) {
  scrape_and_call(x,
                  pass="specMATRIX",
                  def=list(oclass="omegalist",type="omega"),
                  narrow=FALSE,...)
}
##' @export
handle_spec_block.specSIGMA <- function(x,...) {
  scrape_and_call(x,
                  pass="specMATRIX",
                  def=list(oclass="sigmalist",type="sigma"),
                  narrow=FALSE,...)
  
}

eval_ENV_block <- function(x,...) {
  e <- new.env()
  if(is.null(x)) return(e)
  x <- try(eval(parse(text=x),envir=e))
  if(inherits(x,"try-error")) {
    stop("Failed to parse code in $ENV",call.=FALSE) 
  }
  return(e)
}  


## S3 methods for processing code blocks
## All of these need to be exported
handle_spec_block <- function(x,...) UseMethod("handle_spec_block")
##' @export
handle_spec_block.default <- function(x,...) return(dump_opts(x))

##' @export 
handle_spec_block.specTABLE <- function(x,...) {
  
  x <- dump_opts(x)
  
  if(any(grepl("\\s*table\\(", x))) {
    stop("The table(name) = value; macro has been deprecated.\n",  
            "Save your output to double and pass to $CAPTURE instead:\n",
            "   $TABLE double name = value;\n   $CAPTURE name")
  }
  
  return(x)
  
}


##' Parse \code{$PARAM} block.
##' 
##' @param x data
##' @param env parse environment
##' @param annotated logical
##' @param pos block position
##' @param object the (character) name of a \code{list} in \code{$ENV} to use for block output
##' @param ... passed
##' 
##' @rdname handle_PARAM
##' 
PARAM <- function(x,env,annotated=FALSE,pos=1,object = NULL,...) {
  
  if(annotated) {
    l <- parse_annot(x,block="PARAM",envir=env$ENV)
    env[["param"]][[pos]] <- l[["v"]]
    env[["annot"]][[pos]] <- l[["an"]]
  } else {
    if(!is.null(object)) {
      x <- get(object,env$ENV) 
    } else {
      x <- tolist(x,envir=env$ENV) 
    }
    env[["param"]][[pos]] <- x
  }
  return(NULL)
}

##' @export
handle_spec_block.specPARAM <- function(x,...) {
  scrape_and_call(x,pass="PARAM",narrow=TRUE,...)
}


##' Parse \code{$FIXED} block.
##' 
##' @param x data
##' @param env parse environment
##' @param annotated logical
##' @param pos parse position
##' @param object the (character) name of a \code{list} in \code{$ENV} to use for block output
##' @param ... passed
##' 
##' @rdname handle_FIXED
##' 
FIXED <- function(x,env,annotated=FALSE,pos=1,object=NULL,...) {
  if(annotated) {
    l <- parse_annot(x,block="FIXED",envir=env$ENV)
    env[["fixed"]][[pos]] <- l[["v"]]
    env[["annot"]][[pos]] <- l[["an"]]
  } else {
    if(!is.null(object)) {
      x <- get(object,env$ENV) 
    } else {
      x <- tolist(x,envir=env$ENV) 
    }
    env[["fixed"]][[pos]] <- x
  }
  return(NULL)
}
##' @export
handle_spec_block.specFIXED <- function(x,...) {
  scrape_and_call(x,pass="FIXED",narrow=TRUE,...)
}

##' Parse \code{$THETA} block.
##' 
##' @param x data
##' @param env parse environment
##' @param annotated logical
##' @param name character prefix for parameter names
##' @param pos parse position
##' @param ... passed
##' 
##' @rdname handle_THETA
##' 
THETA <- function(x,env,annotated=FALSE,pos=1,name="THETA",...) {
  
  if(annotated) {
    l <- parse_annot(x,noname=TRUE,block="THETA",envir=env$ENV)
    x <- as.numeric(l[["v"]])
  } else {
    x <- tolist(paste0(cvec_cs(x),collapse=','),envir=env$ENV)
  }
  
  x <- x[!is.na(x)]
  names(x) <- paste0(name, 1:length(x))
  env[["param"]][[pos]] <- x
  return(NULL)
}
##' @export
handle_spec_block.specTHETA <- function(x,...) {
  scrape_and_call(x,pass="THETA",...)
}


##' Parse \code{$INIT} block.
##' 
##' @param x data
##' @param env parse environment
##' @param annotated logical
##' @param pos block position
##' @param object the (character) name of a \code{list} in \code{$ENV} to use for block output
##' @param ... passed
##' 
##' @rdname handle_INIT
##' 
INIT <- function(x,env,annotated=FALSE,pos=1,object=NULL,...) {
  if(annotated) {
    l <- parse_annot(x,block="INIT",envir=env$ENV)
    env[["init"]][[pos]] <- l[["v"]]
    env[["annot"]][[pos]] <- l[["an"]]
  } else {
    if(!is.null(object)) {
      x <- get(object,env$ENV)
    }  else {
      x <- tolist(x,envir=env$ENV) 
    }
    env[["init"]][[pos]] <- x
  }
  return(NULL)
}
##' @export
handle_spec_block.specINIT <- function(x,...) {
  scrape_and_call(x,pass="INIT",narrow=TRUE,...)
}


##' Parse \code{$CMT} block.
##' 
##' @param x data
##' @param env parse environment
##' @param annotated logical
##' @param pos block position
##' @param object the (character) name of a \code{list} in \code{$ENV} to use for block output
##' @param ... passed
##' 
##' @rdname handle_CMT
##' 
CMT <- function(x,env,annotated=FALSE,pos=1,object=NULL,...) {
  
  if(annotated) {
    l <- parse_annot(x,novalue=TRUE,block="CMT",envir=env$ENV)
    env[["annot"]][[pos]] <- l[["an"]]
    x <- names(l[["v"]])
  } else {
    if(!is.null(object)) {
      x <- get(object,env$ENV) 
    } else {
      x <- tovec(x)
    }
  }
  
  l <- rep(0,length(x))
  names(l) <- x
  env[["init"]][[pos]] <- as.list(l)
  return(NULL)
}
##' @export
handle_spec_block.specCMT <- function(x,...) {
  scrape_and_call(x,pass="CMT",narrow=FALSE,...)
}
##' @export
handle_spec_block.specVCMT <- handle_spec_block.specCMT
##' @export
handle_spec_block.specSET <- function(x,...) {
  tolist(dump_opts(x))
}
##' @export
handle_spec_block.specNMXML <- function(x,...) {
  parseNMXML(dump_opts(x),...)
}
##' @export
handle_spec_block.specCMTN <- function(x,...) {
  cvec_cs(dump_opts(x))
}


##' Parse \code{$CAPTURE} block.
##' 
##' @param x block text
##' @param env parse environment
##' @param annotated logical
##' @param pos parse position
##' @param ... not used
##' 
##' 
CAPTURE <- function(x,env,annotated=FALSE,pos=1,...) {
  if(annotated) {
    l <- parse_annot(x,novalue=TRUE,block="CAPTURE",envir=env$ENV)
    env[["annot"]][[pos]] <- l[["an"]]
    x <- names(l[["v"]])
  }
  x <- c(cvec_cs(x),env$capture)
  
  return(unique(x))
}

##' @export
handle_spec_block.specCAPTURE <- function(x,...) {
  scrape_and_call(x,pass="CAPTURE",...)
}

##' @export
handle_spec_block.specPKMODEL <- function(x,...) {
  x <- scrape_opts(x)
  do.call("PKMODEL",x)
}
##' @export
handle_spec_block.specINCLUDE <- function(x,...) {
  
  x <- cvec_c_tr(dump_opts(x))
  
  if(any(grepl("[\"\']",x,perl=TRUE))) {
    stop("Items in $INCLUDE should not contain quotation marks.",call.=FALSE) 
  }
  
  if(any(!grepl("^.*\\.h$",x,perl=TRUE))) {
    warning("$INCLUDE expects file names ending with .h",call.=FALSE) 
  }
  
  return(x)
}

form_includes <- function(x,where) {
  if(is.null(x)) return(NULL)
  files <- file.path(where,x)
  if(!all(file.exists(files))) {
    stop("All header files in $INCLUDE must exist in the project directory",call.=FALSE) 
  }
  md <- tools::md5sum(file.path(where,x))
  paste0("#include \"", x, "\" // ", md)
}
##' @export
handle_spec_block.specPLUGIN <- function(x,...) {
  x <- unique(cvec_c_tr(x))
  if("mrgx" %in% x) {
    warning("There are currently no functions provided by the mrgx plugin. All functions previously provided by mrgx can be called from the R namespace (e.g. R::rnorm(10,2)).", call.=FALSE)
  }
  if(length(x) ==0) return(list())
  return(x)
}

##' Parse data from \code{$PKMODEL}
##'
##' @param ncmt number of compartments; must be 1 (one-compartment, not including a depot dosing compartment) or 2 (two-compartment model, not including a depot dosing compartment)
##' @param depot logical indicating whether to add depot compartment
##' @param trans the parameterization for the PK model; must be 1, 2, 4, or 11
##' @param ... not used
##'
##' @details
##' When using \code{$PKMODEL}, certain symbols must be defined in the model specification depending
##' on the value of \code{ncmt}, \code{depot} and \code{trans}.
##'
##' \itemize{
##' \item \code{ncmt} 1, \code{depot FALSE}, trans 2: \code{CL}, \code{V}
##' \item \code{ncmt} 1, \code{depot TRUE} , trans 2: \code{CL}, \code{V}, \code{KA}
##' \item \code{ncmt} 2, \code{depot FALSE}, trans 4: \code{CL}, \code{V2}, \code{Q}, \code{V3}
##' \item \code{ncmt} 2, \code{depot TRUE} , trans 4: \code{CL}, \code{V2}, \code{Q}, \code{V3}, \code{KA}
##'
##' }
##'
##' If \code{trans=11} is specfied, use the symbols listed above for the \code{ncmt} / \code{depot} combination, but append \code{i} at the end (e.g. \code{CLi} or \code{Qi} or \code{KAi}).
##'
##' If \code{trans=1}, the user must utilize the following symbols:
##'
##' \itemize{
##' \item \code{pred_CL} for clearance
##' \item \code{pred_V}  or \code{pred_V2} for central compartment volume of distribution
##' \item \code{pred_Q}  for intercompartmental clearance
##' \item \code{pred_V3} for for peripheral compartment volume of distribution
##' \item \code{pred_KA} for absorption rate constant
##'
##' }
##'
##'
PKMODEL <- function(ncmt=1, depot=FALSE, trans = pick_trans(ncmt,depot), ...) {
  stopifnot(ncmt %in% c(1,2))
  advan <- pick_advan(ncmt,depot)
  return(list(advan=advan, trans=trans, n=ncmt))
}

## Collect PKMODEL information; hopefully will be deprecating ADVAN2 and ADVAN4 soon
collect_subr <- function(x,what=c("PKMODEL")) {
  
  ans <- list(advan=13,trans=1,strict=FALSE)
  
  y <- x[names(x) %in% what]
  
  if(length(y) >  1) stop("Only one $PKMODEL block is allowed.",call.=FALSE)
  if(length(y) == 0) return(ans)
  ## Get rid of this once ADVANn are deprecated
  if(names(y) %in% c("PKMODEL")) {
    ans <- y[[1]]
  }
  
  if(ans[["advan"]] != 13) {
    if(any(is.element(c("VCMT"),names(x)))) stop("Found $VCMT and $PKMODEL in the same control stream.")
    if(any(is.element("ODE", names(x)))) stop("Found $ODE and $PKMODEL in the same control stream.")
  }
  
  ans[["n"]] <- ans[["advan"]] - as.integer(ans[["advan"]] > 2)
  
  return(ans)
}


dosing_cmts <- function(x,what) {
  if(!is.character(x)) return(character(0))
  x <- unlist(strsplit(x,"\n"))
  m <- regexpr("(ALAG|F|R|D)\\_[^= ]+", x, perl=TRUE)
  m <- regmatches(x,m)
  m <- unique(gsub("(ALAG|F|R|D)\\_", "",m))
  m <- intersect(m,what)
  return(m)
}

## Picks the default trans
pick_trans <- function(ncmt,depot) {
  switch(pick_advan(ncmt,depot),
         `1` = 2,
         `2` = 2,
         `3` = 4,
         `4` = 4
  )
}

## Picks advan based on ncmt and depot status
pick_advan <- function(ncmt,depot) {
  ncmt + as.integer(depot) + as.integer(ncmt==2)
}

check_pred_symbols <- function(x,code) {
  p <- pars(x)
  code <- unlist(get_tokens(code,TRUE))
  have <- unique(c(p,code))
  
  if(x@trans==1) return(invisible(NULL))
  
  need <- GLOBALS$ADVAN_PARMS[[as.character(x@advan)]]
  # assuming error checking has already processed for a valid advan,
  # however could add error check here with if (is.null(need)) {stop(...)}
  if(x@trans==11) need <- paste0(need,"i")
  if(!all(need %in% have)) {
    diff <- setdiff(need,have)
    stop(GLOBALS$PKMODEL_NOT_FOUND,paste(diff, collapse=","),call.=FALSE)
  }
  return(invisible(NULL))
}


parse_env <- function(n,ENV=new.env()) {
  mread.env <- new.env()
  mread.env$param <- vector("list",n)
  mread.env$fixed <- vector("list",n)
  mread.env$init  <- vector("list",n)
  mread.env$omega <- vector("list",n)
  mread.env$sigma <- vector("list",n)
  mread.env$annot <- vector("list",n)
  mread.env$capture <- character(0)
  mread.env$ENV <- ENV 
  mread.env
}

